## 소프트웨어 공학
1. **소프트웨어 공학**의 정의 : 소프트웨어 위기를 극복하고 효율적으로 품질 높은 소프트웨어를 개발하기 위한 학문
2. 소프트웨어 공학의 **3R**
  - 완성된 소프트웨어로 역공학, 재공학, 재사용을 통핸 소프트웨어의 생산성을 극대화
  - 역공학(Reverse Engineering) : 기존 개발된 시스템을 CASE도구를 이용하여 요구분석, 설계서 등의 문서로 추출하는 작업
  - 재공학(Re-engineering) : 기존 소프트웨어의 기능을 개선시키거나 유지보수의 생산성으로 해결하려는 방법 (재공학 과정: **분석 -> 재구성 -> 역공학 -> 이관**)
  - 재사용(Reuse) : 이미 개발된 소프트웨어의 전체, 일부분을 다시 사용하는 것(함수, 객체, 컴포넌트, 애플리케이션 재사용) 합성중심(블록을 만들어서 끼워 맞춰서 완성시킴), 생성중심(추상화 형태로 쓰여진 명세를 구체화하여 만듦)

3. 소프트웨어 개발 단계 : 계획 - 요구사항 분석 - 설계 - 구현 - 테스트 - 유지보수
  - 계획 : 무엇을 개발할 것인지 명확하게 정의(개발업체에서 수행x), 비용과 기간을 예측하는 단계
  - 분석 : 개발할 소프트웨어의 기능과 제약조건, 목표를 고객과 함께 정의한다. 요구사항의 정확한 이해 및 요구사항을 유도한다.
  - 설계 : **시스템이 어떻게 동작하는지 정의**하고 산출된 요구사항을 기준으로 입력, 처리, 출력 등을 정의(시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계)
  - 구현 : 프로그래밍 언어를 이용하여 실제로 프로그램을 작성, 코딩과 디버깅이 이루어지며 단위테스트 진행
  - 테스트 : 구현된 소프트웨어가 요구사항을 만족하는지 검사
  - 유지보수 : 문제점을 수정하고 새로운 기능을 추가, 소프트웨어를 좀 더 발전시키는 단계

## 소프트웨어 개발 방법론
1. 구조적 방법론 : 절자지향 소프트웨어 개발 방법론으로 제한된 구조에서 코드 생성 및 순차적 실행
  - 계분설구테유 과정 거침
  - 구성요소 : 데이터 흐름도(DFD), 자료사전(DD), 상태전이도(STD), 소단위명세서(Minispec)
2.  정보공학 방법론 : **기업**에서 사용하는, 기업의 경령전략에 초점을 두는 데이터 중심 방법론
  - 계분설구테유 기본 과정 거침

3. 객체지향 개발 방법론 : 현실세계의 객체를 속성과 메서드로 형태로 표현한 것
  - 캡슐화, 정보은닉, 상속, 다형성, 추상화  

4. CBD 분석 방법론(Component Based Development)
  - 재사용 가능한 컴포넌트의 개발, 상용 컴포넌트를 조합해서 애플리케이션을 개발한다.

5. 애자일 방법론
  - XP, SCRUM, FDD, Crystal, ASD, Lean 등
    - XP: 5가지의 핵심가치와 12개의 실천항목, 문서보다는 코드를 중요시 함.
      - **용기, 단순성, 의사소통, 피드백, 존중**
      - 짝 프로그래밍, 계획 세우기, 테스트 기반 개발(TDD), 고객 상주, 지속적인 통합(CI), 코드 개선, 작은 릴리즈, 코딩 표준, 공동 코드 소유, 간단한 디자인, 시스템 메타포어, 작업시간 준수
    - 스크럼 : 개발 주기는 30일 정도(스플린트 단위)로 조절하고 개발 주기마다 실제 동작할 수 있는 결과를 제공해야 한다.
      - 항상 팀 단위로 생각하고 날마다 15분 정도의 회의를 한다.
      - 제품 백로그: 개발할 제품에 대한 요구사항 목록
      - 스프린트 : 반복적인 개발 주기(1~3주의 짧은 기간을 목표로 설정)
      - 스프린트 계획 회의: 스프린트 목표와 스프린트 백로그를 계획
      - 스프린트 백로그: 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록
      - 일일 스크럼 회의
      - 실행 가능한 제품 
      - 제품 책임자 : 제품 백로그를 정의하여 우선순위를 정해준다. (PL)
      - 스크럼 마스터 : 프로젝트 관리자, 스크럼 프로세스를 따르고 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡음.(PM)
  - 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식
  - 경량 프로세스

6. 폭포수 모델(Waterfall Model) : 계분설구테유 전 과정을 순차적으로 접근하는 개발모델
7. 프로토타이핑 모델(Prototyping Model) : 고객이 요구한 주요 기능을 프로토타입으로 구현해서 완성하는 모델, 시재품
  - 계획수립 > ((프로토타입 개발 > 평가 : 반복)) > 구현 > 인수
9. 나선형 모델(Sprial Model) : 폭포수 모델과 프로토타이핑 모델의 장점을 수용하고 위험분석을 추가한 점증적 개발 모델
  - 계획 - 위험분석 - 개발 - 고객평가 단계가 점진적으로 발전

10. RAD(Rapid Application Development) 모델 : 매우 짧은 개발 주기(60~90일)를 강조하는 점진적 소프트웨어 개발 방식, case 도구를 이용해서 시스템 개발

11. **V 모형** : 폭포수 모델에 테스트 작업을 강조한 것
  - 단위 > 통합 > 시스템 > 인수

12. 4세대 기법 : 요구사항 명세로부터 원시코드를 자동으로 생성할 수 있게 해주는 모델
13. IT 서비스 관리
  - SLM(Service Level Management) : IT 서비스의 품질을 높이는 일련의 관리 및 활동
  - SLA(Service Level Agreement) : IT 서비스 수준을 명시적으로 정의한 문서
  - ITSM(Information Technology Service Management) : 서비스 수준(SLA)에 맞는 IT서비스를 제공하는 것
  - ITIL(IT INfrastructure Library) : IT서비스를 쉽게 제공하고 관리할 수 있는 가이드, 프레임워크이다. ITSM을 실현하는 도구/방법



## 프로젝트 계획

1. 프로젝트 핵심 관리대상(3p)
  - 사람(People) : 프로젝트 관리 가장 기본 요소
  - 문제(Problem) : 처리해야 할 내용 분석, 설계
  - 프로세스(Process) : 소프트웨어 개발에 필요한 골격 제공

2. PMBOK(Project Management Body Of Knowledge) : PMI에서 제작한 프로젝트 관리 프로세스 및 지식체계(자격증)
  - pmbok 5단계 프로세스 그룹 : 프로젝트 착수(광범위한 프로젝트 범위 정함) > 프로젝트 게획(세부 범위 정함) > 프로젝트 실행(개발, 완료되는 단계) > 프로젝트 통제(진척상황 모니터링,성과 측정) > 프로젝트 종료(요구사항 만족 검증, 고객으로부터 확인 받는 단계)

3. 개발 비용 산정
  - 하향식 산정 기법 : 전문가 판단기법(경험이 많은 개발자에게 비용산정 의뢰), 델파이 기법(여러 전문가의 의견을 종합해서 비용산정)
  - 상향식 산정 기법 : 
    - 원시코드 라인수(LOC - 비관치, 낙관치, 중간치를 측정해서 예측치 구해서 비용산정), 낙관치+(4*중간치)+비관치/6
    - 개발 단계별 노력 기법(맨먼스)
  - 수학적 산정 기법
    - COCOMO: 개발할 소프트웨어 규모를 예측한 후 종류에 따라 비용 산정 공식에 대입하여 비용 산정
    - 조직형(Organic Mode)-5만라인 이하/일반 업무용, 반분리형(Semidetached Mode)-30만라인 이하/운영체제, 내장형(Embedded Mode)-30만라인 이상/미사일 유도
    - Putnam : Reyleigh-Norden곡선의 노력 분포도를 기초로 한다. SLIM이라는 자동화 추정도구 사용
    - Function Point(FP, 기능점수) : ESTIMACS 자동화 추정도구 사용, 소프트웨어가 가지는 기능의 개수를 기준으로 소프트웨어의 규모를 측정한다.
      - 소프트웨어 기능 분류 : 데이터 기능(내부 논리파일, 외부 연계파일) / 트랜잭션 기능(외부입력, 외부출력, 외부조회)
      - 비용산정에 이용되는 요소 : 자료입력(입력 양식), 정보출력(출력보고서), 명령어(사용자 질의수), 데이터파일, 필요한 외부 루틴과의 인터페이스


4. 개발 일정 산정
  - 작업분해(WBS) - CPM네트워크 작성 - 최소 소요기간(최대일수도) 구함 - 소요 M/M, 기간 산정하여 CPM 수정 - 간트차트로 표현
  - WBS(Work Breakdown Structure) : 프로젝트 목표 달성위해 필요한 활동과 업무를 세분화하는 작업
  - PERT : 미 해군이 일정계획 및 진행과정을 효율적으로 관리하기 위해 개발됨, 프로젝트 시간단축이 목표, 예측치 구하는 건 LOC 기법이랑 똑같음
  - CPM : 듀폰+레밍톤사의 화학공장 유지 및 관리를 위해 개발됨. 전체 프로젝트의 시간단축을 목표로 함.
    - PERT/CPM : 작업의 선/후행 관계를 고려하여 전체작업의 완료시간을 결정하고 추가비용 투입을 고려하여 전체작업 완료시간을 단축하는 네트워크 분석 기법
    - 임계경로(Critical path) : 가장 오래 걸리는 시간을 구하면 됨. 프로젝트를 끝내기 위한 필요한 최소 소요시간

  - 간트차트(Gantt chart) : 일정계획의 최종 산출물, 바 형태의 도구, 각 업무별로 일정의 시작과 끝을 그래픽으로 표시하여 전체 일정을 한 눈에 보는 차트


## 요구사항 분석
1. 플랫폼의 기능: 연결기능 ,비용 감소, 브랜드 신뢰 기능, 커뮤니티 형성
2. 플랫폼의 유형 : 싱글 사이드 플랫폼, 투사이드 플랫폼, 멀티 사이드 플랫폼
3. CPND(Contents Platform Network Device) : 콘텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 사용자의 단발기로 서비스가 이루어짐을 표혀하는 무선 인터넷 서비스 가치 사슬
4. 운영체제 : 컴퓨터 시스템 자원을 효율적으로 관리하여 사용자가 컴퓨터를 편리하게 사용할 수 있도록 환경을 제공해주는 시스템 소프트웨어
5. 네트워크: 노드들이 자원을 공유할 수 있게 하는 디지털 전기 통신망, 노드간 연결을 통해 서로에게 데이터를 교환
6. 프로토콜의 3요소 : 구문(Syntax), 의미(Semantic), 타이밍(timing)
7. DBMS : 사용자, 애플리케이션 등의 상호작용을 위해 데이터를 저장하고 분석하는 소프트웨어
8. 미들웨어 : 양쪽을 연결하여 데이터를 주고받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어
  - 원격 프로시저 호출(RPC) : 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템
  - 메시지 지향 미들웨어(MOM) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
  - ORB : 객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있는 미들웨어
  - DB 접속 미들웨어 : 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어(ODBC, JDBC)
  - TP모니터 : 트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어
  - 웹 애플리케이션 서버(WAS) : 동적인 콘텐츠를 처리하기 위한 미들웨어
  - 엔터프라이즈 서비스 버스(ESB) : 메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 지원하는 미들웨어

9. 요구공학
  - 고객 요구를 체계적으로 수집, 분석, 명세화, 검증하고 추적, 변경되는 요구사항을 도출하고 관리하는 기법
  - 기능적 요구사항 : 소프트웨어를 구성하는 기능들이 무엇인지 정의
  - 비기능적 요구사항 : 소프트웨어 기능들에 대한 조건과 제약사항들이 무엇인지 정의하 ㄴ것. 보안, 성능, 품질, 안전성 등
  - 요구사항 개발 프로세스 : 도출(eliciation) - 분석(analysis) - 명세(specification) - 확인(Validation)
  - 도출 : 요구사항이 어디 있고 어떻게 수집할 것인지 확인(인터뷰, 관찰, 문화 기술적 연구, 사용자 스토리, 시나리오, 설문조사, 브레인스토밍, 포커스그룹)
  - 분석 : 요구사항들 간에 상충되는 것을 해결. 
    - 구조적 분석도구 : DFD, DD, Mini-spec, ERD, STD
    - 객체지향 분석도구 : UML, 모델링

  - 명세 : 체계적으로 검토, 평가, 승인 될수 있는 문서를 작성
    - 정형 명세기법(수학, 논리학, 약속된 기호로 표시, 명세 오류 및 모호성 쉽게 파악, 작성 어렵고 시간 많이 걸림, VDM, Z, PETRI-NET, CSP) 
    - 비정형 명세기법(자연어, 그림 중심, 내용 모호하고 완전한 검증 곤란, SADT, ER모델링, FSM)
    - 산출물 : 시스템 정의서, 시스템 요구사항 명세서, 소프트웨어 요구사항 명세서 
  - 확인 : 분석가가 요구사항을 이해했는지 확인하고 요구사항 문서가 일관성있고 완전한지 검증한다.
  - 요구사항 분류(기능/비기능 분류) > 개념 모델링 > 요구사항 할당 > 요구사항 협상 > 정형분석

10. CASE도구 : 요구사항을 자동으로 분석하고 요구사항 분석 명세서를 기술하는 도구
  - 상위 케이스 도구: 생명주기 전반부에 사용, 계획과 요구분석, 설계 단계 지원.
  - 하위 케스트 도구 : 생명주기 후반부에 사용, 코드의 작성과 테스트 문서화 하는 과정을 지원함.
  - 통합 케이스 도구 : 소프트웨어 생명주기에 포함되는 전체 과정을 지원한다.
  - SADT : softtech사에서 개발, 구조적 분석 및 설계도구
  - TAGS : 시스템 공학 방법 응용에 대한 자동 접근 방법
  - PSL/PSA : 미시간 대학에서 개발한 것
  - SREM : 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발
11. HIPO(Hierachy inut process output)
  - 하향식 소프트웨어 개발을 위한 문서화 도구
  - 가시적 도표(Visual table of content): 시스템의 전체 기능과 흐름을 보여주는 트리구조, 입처출 없음
  - 총체적 도표(overview diagram): 프로그램을 구성하는 기능을 기술한 것. 입처출에 대한 전반적인 정보 제공
  - 세부적 도표(detail diagram): 총체적 도표에 표시된 기능을 구성하는 기본요소들을 상세히 기술하는 도표

12. 모델링
  - 기능적  모델링: 시스템 기능을 사용자 관점으로 표현
  - 정적 모델링: 시스템을 구조화하여 클래스 단위로 표현(클래스 다이어그램)
  - 동적 모델링: 시스템이 어떤 기능을 수행하는지의 상호작용을 표현(순서, 상태, 커뮤니케이션 다이어그램)
13. 분석 모델
  - 구조적 분석 모델 : 하향식 기능 분해 기법, 절차적
    - 자료흐름도: 자료 흐름과 처리 과정을 도형 중심으로 기술
      - 처리과정(process) : 자료를 변환시키는 처리과정 ㅇ
       - 자료 저장소(data store) : 자료가 저장되는 곳 =
       - 단말(terminator) 데이터의 입출력 주체 ㅁ
    - 자료 사전: 자료흐름도에 기술된 모든 자료들에 대한 사항을 자세히 정의        
    - 소단위 명세서: 자료 흐름도에서 어떤 일이 수행되는지 정의
    - 개체 관계도(ERD) : 시스템에서 처리되는 개체와 개체의 구성과 속성, 개체간의 관계를 표현하여 자료 모델링
    - 상태전이도(STD) : 시스템의 상태와 상태간의 전이를 모델화                        
  - 객체 지향 분석 모델 : 사용자의 욕구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 관련된 속성과 연산, 그들간의 관계를 정의하여 모델링
  - 럼바우(Rumbaugh) : 분석 활동을 객체모델(객체 다이어그램), 동적모델(상태 다이어그램), 기능모델(자료흐름도) 순서로 나누어서 수행
  - 부치(booch): 미시적 프로세스와 거시적 프로세스 모두 사용하는 분석방법
  - Jacobson : usecase를 강조하여 사용
  - coad-yourdon : ER다이어그램을 이용
  - Wirfs-brock : 분석과 설계에 명확한 구분이 없다.


## 소프트웨어 설계의 기본 원칙
1. 소프트웨어 설계의 종류
  - 상위 설계 : 아키텍처 설계(시스템 전체적인 구조 설계), 데이터 설계(시스템에 필요한 정보 설계), 인터페이스 정의(시스템의 구조와 서브시스템들 사이 인터페이스를 명확히 정의), 사용자 인터페이스 설계(사용자가 익숙하고 편리하도록 인터페이스 설계/UI,UX)
  - 하위 설계 : 모듈 설계, 자료구조 설계, 알고리즘 설계(실제 구현단계에서 설계)
2. 소프트웨어 설게의 원리
  - 분할과 정복(Divide & conquer) : 규모가 큰 소프트웨어를 여러개의 작은 서브시스템으로 나누어 하나씩 완성시킴
  - 추상화(Astraction) : 실세계의 복잡한 상황을 간결하고 명확하게 핵심 위주로 단순화시킴.
    - 추상화 기법: 과정 추상화, 자료 추상화, 제어 추상화
  - 단계적 분해(Gradual Decomposition) : 기능을 점점 작은 단위로 나누어서 점차적으로 구체화
  - 모듈화(Modulization) : 실제로 개발할 수 있는 작은 단위로 나눔
  - 정보은닉(Infomation Hiding) : 다른 객체에게 자신의 정보를 숨이고 자신의 연산만을 통해 접근이 가능하도록 함.
3. 설계 모델링: 소프트웨어를 구성하는 모듈을 식별하고 연결을 그림으로 표현한 것
  - 구조 모델링: 시스템의 구성 요소들과 이들 사이의 구조적인 관계와 특성들의 모델링, UML 정적 다이어그램
  - 행위 모델링: 소프트웨어의 구성요소들이 언제 어떤 순서로 기능을 수행해야 작용하는지를 모델링, UML 동적 다이어그램
4. 소프트웨어 설계 유형
  - 아키텍처 설계, 데이터베이스 설계, 서비시스템 설계, 컴포넌트 설계, 자료구조와 알고리즘 설계
    - 협약에 의한 설계 : 클래스에 대한 여러 가정을 공유하는 명세
    - 선행조건: 사용 전에 참이 되어야 할 조건
    - 결과조건: 사용 후 만족되어야 할 결과조건
    - 불변조건: 오퍼레이션이 실행되는 동안 항상 만족되어야 

## 소프트웨어 아키텍처
1. 소프트웨어의 골격이 되는 기본구조
2. 간략성, 추상화, 가시성, 관점 모형, 의사소통 수단으로 활용
3. 소프트웨어 아키텍처 프레임워크 구성요소 : 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰(4+1뷰)
4. 4+1뷰
  - 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점(만드는 사람의 관점)에서 바라보는 소프트웨어적인 접근 방법
  -  논리적 뷰: 시스템의 기능적인 요구사항 logical
  -  구현 뷰: 개발환경 안에서 정적인 소프트웨어 모듈 구성 implement
  -  배치 뷰: 컴포넌트가 물리적인 노드에 어떻게 배치되는가를 보여준다. deployment
  -  프로세스 뷰 : 프로그램 실행 시 시스템의 표현 process
  -  유논프구배
  - 유스케이스뷰 : 사용자 관점, 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰
 5. 소프트웨어 아키텍처 품질속성 : 정확성(Correctness), 신뢰성(Realiability), 효율성(Efficiency), 무결성(Integrity), 사용 용이성(Usability), 유지보수성(Maintainability), 시험용이성(Testability), 유연성(Flexibility), 이식성(Potability), 재사용성(Reusability), 상호운용성(Interoperability)
 6. 소프트웨어 아키텍처 평가기법 유형 : 가시적/비가시적 , 이른평가/늦은평가
 7. 소프트웨어 아키텍처 패턴 : 소프트웨어 아키텍처의 공통적인 발생문제에 대한 재사용 가능한 해결책
  - 계층화 패턴(Layerend pattern) : N-티어, 각 서브 시스템이 하나의 계층이 되고 하위층이 제공하는 서비스를 상위층의 서브시스템이 이용할 수 있다.
  - 클라이언트-서버 패턴 : 다수의 클라이언트와 하나의 서버로 구성, 서버는 클라이언트에게 서비스를 제공하며 데이터를 관리하는 역할
  - 마스터-슬레이브 패턴 : 마스터 컴포넌트가 동등한 구조의 슬레이브 컴포넌트로 작업을 분산하고, 슬레이브가 결과값을 반환하면 최종 결과값을 계산하는 구조
  - 파이프-필터 패턴 : 서브 시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정 반복
  - 브로커 패턴 :  분리된 컴포넌트로 구성된 분산 시스템에서 사용
  - 피어투피어 패턴 : 피어라 부르는 각 컴포넌트 간에 서비스를 주고받는 패턴
  - 이벤트-버스 패턴 : 이벤트 버스를 통해 특정 채널로 메시지 발행, 리스너가 구독한 채널에 소스가 서비스를 제공하면 채널이 리스너에게 서비스를 제공
  - 모델뷰컨트롤러 패턴(MVC) : 3개의 각 컴포넌트는 각자의 역할을 갖고 사용자에게 서비스 제공, 
