## 소프트웨어 공학
1. **소프트웨어 공학**의 정의 : 소프트웨어 위기를 극복하고 효율적으로 품질 높은 소프트웨어를 개발하기 위한 학문
2. 소프트웨어 공학의 **3R**
  - 완성된 소프트웨어로 역공학, 재공학, 재사용을 통핸 소프트웨어의 생산성을 극대화
  - 역공학(Reverse Engineering) : 기존 개발된 시스템을 CASE도구를 이용하여 요구분석, 설계서 등의 문서로 추출하는 작업
  - 재공학(Re-engineering) : 기존 소프트웨어의 기능을 개선시키거나 유지보수의 생산성으로 해결하려는 방법 (재공학 과정: **분석 -> 재구성 -> 역공학 -> 이관**)
  - 재사용(Reuse) : 이미 개발된 소프트웨어의 전체, 일부분을 다시 사용하는 것(함수, 객체, 컴포넌트, 애플리케이션 재사용) 합성중심(블록을 만들어서 끼워 맞춰서 완성시킴), 생성중심(추상화 형태로 쓰여진 명세를 구체화하여 만듦)

3. 소프트웨어 개발 단계 : 계획 - 요구사항 분석 - 설계 - 구현 - 테스트 - 유지보수
  - 계획 : 무엇을 개발할 것인지 명확하게 정의(개발업체에서 수행x), 비용과 기간을 예측하는 단계
  - 분석 : 개발할 소프트웨어의 기능과 제약조건, 목표를 고객과 함께 정의한다. 요구사항의 정확한 이해 및 요구사항을 유도한다.
  - 설계 : **시스템이 어떻게 동작하는지 정의**하고 산출된 요구사항을 기준으로 입력, 처리, 출력 등을 정의(시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계)
  - 구현 : 프로그래밍 언어를 이용하여 실제로 프로그램을 작성, 코딩과 디버깅이 이루어지며 단위테스트 진행
  - 테스트 : 구현된 소프트웨어가 요구사항을 만족하는지 검사
  - 유지보수 : 문제점을 수정하고 새로운 기능을 추가, 소프트웨어를 좀 더 발전시키는 단계

## 소프트웨어 개발 방법론
1. 구조적 방법론 : 절자지향 소프트웨어 개발 방법론으로 제한된 구조에서 코드 생성 및 순차적 실행
  - 계분설구테유 과정 거침
  - 구성요소 : 데이터 흐름도(DFD), 자료사전(DD), 상태전이도(STD), 소단위명세서(Minispec)
2.  정보공학 방법론 : **기업**에서 사용하는, 기업의 경령전략에 초점을 두는 데이터 중심 방법론
  - 계분설구테유 기본 과정 거침

3. 객체지향 개발 방법론 : 현실세계의 객체를 속성과 메서드로 형태로 표현한 것
  - 캡슐화, 정보은닉, 상속, 다형성, 추상화  

4. CBD 분석 방법론(Component Based Development)
  - 재사용 가능한 컴포넌트의 개발, 상용 컴포넌트를 조합해서 애플리케이션을 개발한다.

5. 애자일 방법론
  - XP, SCRUM, FDD, Crystal, ASD, Lean 등
    - XP: 5가지의 핵심가치와 12개의 실천항목, 문서보다는 코드를 중요시 함.
      - **용기, 단순성, 의사소통, 피드백, 존중**
      - 짝 프로그래밍, 계획 세우기, 테스트 기반 개발(TDD), 고객 상주, 지속적인 통합(CI), 코드 개선, 작은 릴리즈, 코딩 표준, 공동 코드 소유, 간단한 디자인, 시스템 메타포어, 작업시간 준수
    - 스크럼 : 개발 주기는 30일 정도(스플린트 단위)로 조절하고 개발 주기마다 실제 동작할 수 있는 결과를 제공해야 한다.
      - 항상 팀 단위로 생각하고 날마다 15분 정도의 회의를 한다.
      - 제품 백로그: 개발할 제품에 대한 요구사항 목록
      - 스프린트 : 반복적인 개발 주기(1~3주의 짧은 기간을 목표로 설정)
      - 스프린트 계획 회의: 스프린트 목표와 스프린트 백로그를 계획
      - 스프린트 백로그: 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록
      - 일일 스크럼 회의
      - 실행 가능한 제품 
      - 제품 책임자 : 제품 백로그를 정의하여 우선순위를 정해준다. (PL)
      - 스크럼 마스터 : 프로젝트 관리자, 스크럼 프로세스를 따르고 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡음.(PM)
  - 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식
  - 경량 프로세스

6. 폭포수 모델(Waterfall Model) : 계분설구테유 전 과정을 순차적으로 접근하는 개발모델
7. 프로토타이핑 모델(Prototyping Model) : 고객이 요구한 주요 기능을 프로토타입으로 구현해서 완성하는 모델, 시재품
  - 계획수립 > ((프로토타입 개발 > 평가 : 반복)) > 구현 > 인수
9. 나선형 모델(Sprial Model) : 폭포수 모델과 프로토타이핑 모델의 장점을 수용하고 위험분석을 추가한 점증적 개발 모델
  - 계획 - 위험분석 - 개발 - 고객평가 단계가 점진적으로 발전

10. RAD(Rapid Application Development) 모델 : 매우 짧은 개발 주기(60~90일)를 강조하는 점진적 소프트웨어 개발 방식, case 도구를 이용해서 시스템 개발

11. **V 모형** : 폭포수 모델에 테스트 작업을 강조한 것
  - 단위 > 통합 > 시스템 > 인수

12. 4세대 기법 : 요구사항 명세로부터 원시코드를 자동으로 생성할 수 있게 해주는 모델
13. IT 서비스 관리
  - SLM(Service Level Management) : IT 서비스의 품질을 높이는 일련의 관리 및 활동
  - SLA(Service Level Agreement) : IT 서비스 수준을 명시적으로 정의한 문서
  - ITSM(Information Technology Service Management) : 서비스 수준(SLA)에 맞는 IT서비스를 제공하는 것
  - ITIL(IT INfrastructure Library) : IT서비스를 쉽게 제공하고 관리할 수 있는 가이드, 프레임워크이다. ITSM을 실현하는 도구/방법



## 프로젝트 계획

1. 프로젝트 핵심 관리대상(3p)
  - 사람(People) : 프로젝트 관리 가장 기본 요소
  - 문제(Problem) : 처리해야 할 내용 분석, 설계
  - 프로세스(Process) : 소프트웨어 개발에 필요한 골격 제공

2. PMBOK(Project Management Body Of Knowledge) : PMI에서 제작한 프로젝트 관리 프로세스 및 지식체계(자격증)
  - pmbok 5단계 프로세스 그룹 : 프로젝트 착수(광범위한 프로젝트 범위 정함) > 프로젝트 게획(세부 범위 정함) > 프로젝트 실행(개발, 완료되는 단계) > 프로젝트 통제(진척상황 모니터링,성과 측정) > 프로젝트 종료(요구사항 만족 검증, 고객으로부터 확인 받는 단계)

3. 개발 비용 산정
  - 하향식 산정 기법 : 전문가 판단기법(경험이 많은 개발자에게 비용산정 의뢰), 델파이 기법(여러 전문가의 의견을 종합해서 비용산정)
  - 상향식 산정 기법 : 
    - 원시코드 라인수(LOC - 비관치, 낙관치, 중간치를 측정해서 예측치 구해서 비용산정), 낙관치+(4*중간치)+비관치/6
    - 개발 단계별 노력 기법(맨먼스)
  - 수학적 산정 기법
    - COCOMO: 개발할 소프트웨어 규모를 예측한 후 종류에 따라 비용 산정 공식에 대입하여 비용 산정
    - 조직형(Organic Mode)-5만라인 이하/일반 업무용, 반분리형(Semidetached Mode)-30만라인 이하/운영체제, 내장형(Embedded Mode)-30만라인 이상/미사일 유도
    - Putnam : Reyleigh-Norden곡선의 노력 분포도를 기초로 한다. SLIM이라는 자동화 추정도구 사용
    - Function Point(FP, 기능점수) : ESTIMACS 자동화 추정도구 사용, 소프트웨어가 가지는 기능의 개수를 기준으로 소프트웨어의 규모를 측정한다.
      - 소프트웨어 기능 분류 : 데이터 기능(내부 논리파일, 외부 연계파일) / 트랜잭션 기능(외부입력, 외부출력, 외부조회)
      - 비용산정에 이용되는 요소 : 자료입력(입력 양식), 정보출력(출력보고서), 명령어(사용자 질의수), 데이터파일, 필요한 외부 루틴과의 인터페이스


4. 개발 일정 산정
  - 작업분해(WBS) - CPM네트워크 작성 - 최소 소요기간(최대일수도) 구함 - 소요 M/M, 기간 산정하여 CPM 수정 - 간트차트로 표현
  - WBS(Work Breakdown Structure) : 프로젝트 목표 달성위해 필요한 활동과 업무를 세분화하는 작업
  - PERT : 미 해군이 일정계획 및 진행과정을 효율적으로 관리하기 위해 개발됨, 프로젝트 시간단축이 목표, 예측치 구하는 건 LOC 기법이랑 똑같음
  - CPM : 듀폰+레밍톤사의 화학공장 유지 및 관리를 위해 개발됨. 전체 프로젝트의 시간단축을 목표로 함.
    - PERT/CPM : 작업의 선/후행 관계를 고려하여 전체작업의 완료시간을 결정하고 추가비용 투입을 고려하여 전체작업 완료시간을 단축하는 네트워크 분석 기법
    - 임계경로(Critical path) : 가장 오래 걸리는 시간을 구하면 됨. 프로젝트를 끝내기 위한 필요한 최소 소요시간

  - 간트차트(Gantt chart) : 일정계획의 최종 산출물, 바 형태의 도구, 각 업무별로 일정의 시작과 끝을 그래픽으로 표시하여 전체 일정을 한 눈에 보는 차트


## 요구사항 분석
1. 플랫폼의 기능: 연결기능 ,비용 감소, 브랜드 신뢰 기능, 커뮤니티 형성
2. 플랫폼의 유형 : 싱글 사이드 플랫폼, 투사이드 플랫폼, 멀티 사이드 플랫폼
3. CPND(Contents Platform Network Device) : 콘텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 사용자의 단발기로 서비스가 이루어짐을 표혀하는 무선 인터넷 서비스 가치 사슬
4. 운영체제 : 컴퓨터 시스템 자원을 효율적으로 관리하여 사용자가 컴퓨터를 편리하게 사용할 수 있도록 환경을 제공해주는 시스템 소프트웨어
5. 네트워크: 노드들이 자원을 공유할 수 있게 하는 디지털 전기 통신망, 노드간 연결을 통해 서로에게 데이터를 교환
6. 프로토콜의 3요소 : 구문(Syntax), 의미(Semantic), 타이밍(timing)
7. DBMS : 사용자, 애플리케이션 등의 상호작용을 위해 데이터를 저장하고 분석하는 소프트웨어
8. 미들웨어 : 양쪽을 연결하여 데이터를 주고받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어
  - 원격 프로시저 호출(RPC) : 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템
  - 메시지 지향 미들웨어(MOM) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
  - ORB : 객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있는 미들웨어
  - DB 접속 미들웨어 : 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어(ODBC, JDBC)
  - TP모니터 : 트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어
  - 웹 애플리케이션 서버(WAS) : 동적인 콘텐츠를 처리하기 위한 미들웨어
  - 엔터프라이즈 서비스 버스(ESB) : 메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 지원하는 미들웨어

9. 요구공학
  - 고객 요구를 체계적으로 수집, 분석, 명세화, 검증하고 추적, 변경되는 요구사항을 도출하고 관리하는 기법
  - 기능적 요구사항 : 소프트웨어를 구성하는 기능들이 무엇인지 정의
  - 비기능적 요구사항 : 소프트웨어 기능들에 대한 조건과 제약사항들이 무엇인지 정의하 ㄴ것. 보안, 성능, 품질, 안전성 등
  - 요구사항 개발 프로세스 : 도출(eliciation) - 분석(analysis) - 명세(specification) - 확인(Validation)
  - 도출 : 요구사항이 어디 있고 어떻게 수집할 것인지 확인(인터뷰, 관찰, 문화 기술적 연구, 사용자 스토리, 시나리오, 설문조사, 브레인스토밍, 포커스그룹)
  - 분석 : 요구사항들 간에 상충되는 것을 해결. 
    - 구조적 분석도구 : DFD, DD, Mini-spec, ERD, STD
    - 객체지향 분석도구 : UML, 모델링

  - 명세 : 체계적으로 검토, 평가, 승인 될수 있는 문서를 작성
    - 정형 명세기법(수학, 논리학, 약속된 기호로 표시, 명세 오류 및 모호성 쉽게 파악, 작성 어렵고 시간 많이 걸림, VDM, Z, PETRI-NET, CSP) 
    - 비정형 명세기법(자연어, 그림 중심, 내용 모호하고 완전한 검증 곤란, SADT, ER모델링, FSM)
    - 산출물 : 시스템 정의서, 시스템 요구사항 명세서, 소프트웨어 요구사항 명세서 
  - 확인 : 분석가가 요구사항을 이해했는지 확인하고 요구사항 문서가 일관성있고 완전한지 검증한다.
  - 요구사항 분류(기능/비기능 분류) > 개념 모델링 > 요구사항 할당 > 요구사항 협상 > 정형분석

10. CASE도구 : 요구사항을 자동으로 분석하고 요구사항 분석 명세서를 기술하는 도구
  - 상위 케이스 도구: 생명주기 전반부에 사용, 계획과 요구분석, 설계 단계 지원.
  - 하위 케스트 도구 : 생명주기 후반부에 사용, 코드의 작성과 테스트 문서화 하는 과정을 지원함.
  - 통합 케이스 도구 : 소프트웨어 생명주기에 포함되는 전체 과정을 지원한다.
  - SADT : softtech사에서 개발, 구조적 분석 및 설계도구
  - TAGS : 시스템 공학 방법 응용에 대한 자동 접근 방법
  - PSL/PSA : 미시간 대학에서 개발한 것
  - SREM : 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발
11. HIPO(Hierachy inut process output)
  - 하향식 소프트웨어 개발을 위한 문서화 도구
  - 가시적 도표(Visual table of content): 시스템의 전체 기능과 흐름을 보여주는 트리구조, 입처출 없음
  - 총체적 도표(overview diagram): 프로그램을 구성하는 기능을 기술한 것. 입처출에 대한 전반적인 정보 제공
  - 세부적 도표(detail diagram): 총체적 도표에 표시된 기능을 구성하는 기본요소들을 상세히 기술하는 도표

12. 모델링
  - 기능적  모델링: 시스템 기능을 사용자 관점으로 표현
  - 정적 모델링: 시스템을 구조화하여 클래스 단위로 표현(클래스 다이어그램)
  - 동적 모델링: 시스템이 어떤 기능을 수행하는지의 상호작용을 표현(순서, 상태, 커뮤니케이션 다이어그램)
13. 분석 모델
  - 구조적 분석 모델 : 하향식 기능 분해 기법, 절차적
    - 자료흐름도: 자료 흐름과 처리 과정을 도형 중심으로 기술
      - 처리과정(process) : 자료를 변환시키는 처리과정 ㅇ
       - 자료 저장소(data store) : 자료가 저장되는 곳 =
       - 단말(terminator) 데이터의 입출력 주체 ㅁ
    - 자료 사전: 자료흐름도에 기술된 모든 자료들에 대한 사항을 자세히 정의        
    - 소단위 명세서: 자료 흐름도에서 어떤 일이 수행되는지 정의
    - 개체 관계도(ERD) : 시스템에서 처리되는 개체와 개체의 구성과 속성, 개체간의 관계를 표현하여 자료 모델링
    - 상태전이도(STD) : 시스템의 상태와 상태간의 전이를 모델화                        
  - 객체 지향 분석 모델 : 사용자의 욕구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 관련된 속성과 연산, 그들간의 관계를 정의하여 모델링
  - 럼바우(Rumbaugh) : 분석 활동을 객체모델(객체 다이어그램), 동적모델(상태 다이어그램), 기능모델(자료흐름도) 순서로 나누어서 수행
  - 부치(booch): 미시적 프로세스와 거시적 프로세스 모두 사용하는 분석방법
  - Jacobson : usecase를 강조하여 사용
  - coad-yourdon : ER다이어그램을 이용
  - Wirfs-brock : 분석과 설계에 명확한 구분이 없다.


## 소프트웨어 설계의 기본 원칙
1. 소프트웨어 설계의 종류
  - 상위 설계 : 아키텍처 설계(시스템 전체적인 구조 설계), 데이터 설계(시스템에 필요한 정보 설계), 인터페이스 정의(시스템의 구조와 서브시스템들 사이 인터페이스를 명확히 정의), 사용자 인터페이스 설계(사용자가 익숙하고 편리하도록 인터페이스 설계/UI,UX)
  - 하위 설계 : 모듈 설계, 자료구조 설계, 알고리즘 설계(실제 구현단계에서 설계)
2. 소프트웨어 설게의 원리
  - 분할과 정복(Divide & conquer) : 규모가 큰 소프트웨어를 여러개의 작은 서브시스템으로 나누어 하나씩 완성시킴
  - 추상화(Astraction) : 실세계의 복잡한 상황을 간결하고 명확하게 핵심 위주로 단순화시킴.
    - 추상화 기법: 과정 추상화, 자료 추상화, 제어 추상화
  - 단계적 분해(Gradual Decomposition) : 기능을 점점 작은 단위로 나누어서 점차적으로 구체화
  - 모듈화(Modulization) : 실제로 개발할 수 있는 작은 단위로 나눔
  - 정보은닉(Infomation Hiding) : 다른 객체에게 자신의 정보를 숨이고 자신의 연산만을 통해 접근이 가능하도록 함.
3. 설계 모델링: 소프트웨어를 구성하는 모듈을 식별하고 연결을 그림으로 표현한 것
  - 구조 모델링: 시스템의 구성 요소들과 이들 사이의 구조적인 관계와 특성들의 모델링, UML 정적 다이어그램
  - 행위 모델링: 소프트웨어의 구성요소들이 언제 어떤 순서로 기능을 수행해야 작용하는지를 모델링, UML 동적 다이어그램
4. 소프트웨어 설계 유형
  - 아키텍처 설계, 데이터베이스 설계, 서비시스템 설계, 컴포넌트 설계, 자료구조와 알고리즘 설계
    - 협약에 의한 설계 : 클래스에 대한 여러 가정을 공유하는 명세
    - 선행조건: 사용 전에 참이 되어야 할 조건
    - 결과조건: 사용 후 만족되어야 할 결과조건
    - 불변조건: 오퍼레이션이 실행되는 동안 항상 만족되어야 

## 소프트웨어 아키텍처
1. 소프트웨어의 골격이 되는 기본구조
2. 간략성, 추상화, 가시성, 관점 모형, 의사소통 수단으로 활용
3. 소프트웨어 아키텍처 프레임워크 구성요소 : 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰(4+1뷰)
4. 4+1뷰
  - 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점(만드는 사람의 관점)에서 바라보는 소프트웨어적인 접근 방법
  -  논리적 뷰: 시스템의 기능적인 요구사항 logical
  -  구현 뷰: 개발환경 안에서 정적인 소프트웨어 모듈 구성 implement
  -  배치 뷰: 컴포넌트가 물리적인 노드에 어떻게 배치되는가를 보여준다. deployment
  -  프로세스 뷰 : 프로그램 실행 시 시스템의 표현 process
  -  유논프구배
  - 유스케이스뷰 : 사용자 관점, 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰
 5. 소프트웨어 아키텍처 품질속성 : 정확성(Correctness), 신뢰성(Realiability), 효율성(Efficiency), 무결성(Integrity), 사용 용이성(Usability), 유지보수성(Maintainability), 시험용이성(Testability), 유연성(Flexibility), 이식성(Potability), 재사용성(Reusability), 상호운용성(Interoperability)
 6. 소프트웨어 아키텍처 평가기법 유형 : 가시적/비가시적 , 이른평가/늦은평가
 7. 소프트웨어 아키텍처 패턴 : 소프트웨어 아키텍처의 공통적인 발생문제에 대한 재사용 가능한 해결책
  - 계층화 패턴(Layerend pattern) : N-티어, 각 서브 시스템이 하나의 계층이 되고 하위층이 제공하는 서비스를 상위층의 서브시스템이 이용할 수 있다.
  - 클라이언트-서버 패턴 : 다수의 클라이언트와 하나의 서버로 구성, 서버는 클라이언트에게 서비스를 제공하며 데이터를 관리하는 역할
  - 마스터-슬레이브 패턴 : 마스터 컴포넌트가 동등한 구조의 슬레이브 컴포넌트로 작업을 분산하고, 슬레이브가 결과값을 반환하면 최종 결과값을 계산하는 구조
  - 파이프-필터 패턴 : 서브 시스템이 입력데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정 반복
  - 브로커 패턴 :  분리된 컴포넌트로 구성된 분산 시스템에서 사용
  - 피어투피어 패턴 : 피어라 부르는 각 컴포넌트 간에 서비스를 주고받는 패턴
  - 이벤트-버스 패턴 : 이벤트 버스를 통해 특정 채널로 메시지 발행, 리스너가 구독한 채널에 소스가 서비스를 제공하면 채널이 리스너에게 서비스를 제공
  - 모델뷰컨트롤러 패턴(MVC) : 3개의 각 컴포넌트는 각자의 역할을 갖고 사용자에게 서비스 제공
  - 블랙보드 패턴: 명확히 정의된 해결 전략이 알려지지 않은 문제에 대해서 유용
  - 인터프리터 패턴: 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용


## UML

1. 시스템 개발 과정에서 이해관계자 사이에 의사소통을 원활하게 이루어지게 하기 위해 표준화된 모델링 언어, 시각화, 문서화
2. UML 특징 : 가시화 언어, 구축 언어, 명세화 언어, 문서화 언어 (가구명문)
3. UML 구성요소 : 사물, 관계, 다이어그램 (사관다)
  - 사물 : 구조사물(시스템의 개념적,물리적 요소), 행동사물(시간과 공간에 따른 요소들의 행위), 그룹사물, 주해사물(부가적 설명이나 제약조건)
  - 관계 : 연의일실포집
    - 연관 accociation 2개 이상 사물이 서로 관련된 관계, 오래 지속되는 관계, 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시
    - 의존 dependency 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시, 한 메서드를 실행하는 동안처럼 짧은 시간만 유지, 오퍼레이션의 매개변수로 사용하는 경우
    - 일반화 generalization 상속, 한 클래스가 다른 클래스를 포함하는 상위 개념일 때의 관계 
    - 실체화 realization 인터페이스를 구현받아 추상 메서들르 오버라이딩 하는 것, 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정
    - 포함 : 집약관계(aggregation)-has a, 각각의 요소들이 연관을 맺음, 합성관계(composition)-긴밀한 필수적 관계ㅡ 전체 객체가 없어지면 부분도 없어짐
  - 다이어그램
    - 구조 다이어그램 -> 정척
      - **클래스** : 클래스의 속성과 클래스 사이의 관곌르 표현
      - 객체 : 클래스에 속한 객체를 특정 시점의 객체와 객체사이의 관계로 표현
      - 컴포넌트: 컴포넌트 사이 관계나 인터페이스를 표현
      - 배치 : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
      - 복합체 : 클래스나 컴포넌트가 복합구조를 가질 때 내부구조 표현
      - 패키지 : 유스케이스나 클래스 등 모델 요소들을 그룹화한 패키지들의 관계 표현
    - 행위 다이어그램 -> 동적
      - **유스케이스** : 시스템의 기능을 나타내기 위해 사용자의 요구를 추출하고 분석하는데 사용/ 액터, 유스케이스, 시스템 
        - 관계 >> 연관관계(실선), 포함관계(include, 반드시실행), 확장관계(extend,특정조건)  <<길러맷>> , 일반화, 
      - **시퀀스** : 객체간의 상호작용 메시지 시퀀스를 시간의 흐름에 따라 나타냄(객체와 생명선, 활성박스, 메시지-동기,비동기,자체,반환)
      - 커뮤니케이션:  동작에 참여한 객체들이 주고받는 메시지와 객체간 연관표현
      - 상태 : 객체가 자신이 속한 클래스의 상태변화및 다른객체간 상호작용에 따라 상태변화 표현
      - 활동 : 시스템이 어떤 기능을 수행하는지에 따라 객체 처리 로직이나 조건에 따라 처리흐름을 순서에 따라 표현
      - 상호작용 : 제어흐름표현
      - 타이밍 : 시간 제약명시적 표현


## UI 설계
1. ui : 컴퓨터, 웹사이트, 시스템 등의 정보기기와 사용자가 서로 상호작용을 할 수 있도록 연결해주는 매개체
2. ux : 사용자가 컴퓨터, 웹사이트, 시스템 등 정보기기의 UI를 직/간접적으로 이용하여 경험한 모든 것
3. UI의 유형 : 
- CLI(=CUI) : 커맨드라인 인터페이스, 키보드를 가지고 서로 소통, 메시지
- GUI : 그래픽 유저 인터페이스, 그래픽, 텍스트, 사용자의 입출력이 마우스를 통해 이루어짐
- NUI : 네츄럴 유저 인터페이스, 인간의 자연스러운 움직임을 인식하여 정보제공
- OUI : 오가닉 유저 인터페이스 : 현실의 모든 것이 입출력장치가 됨

4. UI 요구사항 : 기능적 / 비기능적 요구사항
- 기능적 요구사항 : 시스템이 제공해야 하는 기능에 대한 요구사항
- 비기능적 요구사항 : 사용성, 효율성, 신뢰성, 유지보수성, 재사용성, 품질에 관한 요구사항
5. UI 설계 절차 : UI 개발 목표및 범위수립 - 전략수립 - 사용자 요구사항 분석 - UI상세설계 - 구현 - 테스트
6. UI 설계 원칙 : 직관성, 유효성(사용자의 목적을 정확하게 달성), 학습성, 유연성
7. UI 설계 도구 
  - 와이어프레임 : 화면 단위의 레이아웃 설계
  - 스토리보드: 개발후 완성된 콘텐츠의 최종결과를 예상할 수 있는 기초문서, 정책, 프로세스 및 콘텐츠 구성, 와이어프레임, 기능 정의 등 대부분의 정보 수록(표지, 문서 버전, INDEX 작성, IA(사이트맵) 작성, 공통모듈 작성, 화면 설계와 설명서 작성)
  - 프로토타입 : 실제 서비스와 흡사한 모형을 만드는 작업, 동적 효과를 적용하여 실제 구현된것처럼 시연
  - 목업: 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
  - 유스케이스: 사용자 측면의 요구사항, 다이어그램 형태로 제작

8. 감성공학 : 인간의 심상을 구체적인 물리적 설계 요소로 번역하여 이를 실현하는 기술
  - 마음속의 이미지를 파악 + 형상화 + 구체적인 제품 생산
  - 감각정 감성 / 기능적 감성 / 문화적 감성
  - 1류(인간의 어휘이용)/ 2(문화적 감성) / 3류접근방법(정량적)


## UI 구현
1. 레이아웃 : 특정 공간에 여러 구성 요소를 보기 좋게 효과적으로 배치하는 작업
- HTML : WWW을 통해 제공되는 정보를 나타낼 목적으로 사용되는 마크업언어
- 시맨틱웹 : header, nav, aside, section, article, footer >> 효율적인 검색을 위해 사용
- CSS : 디자인, 반응형 웹, 자스랑 연계 가능
- 자바스크립트 : 모질라 재단의 프로토타입 기반의 프로그래밍 언어, 스크립트 언어(react=-페이스북,vue.js-이븐 어쩌구, angualJS-구글, Ajax-비동기적인 웹 애플리케이션의 제작을 위한 웹개발 기법)
- 웹 표준: 월드와이드웹의 측면을 서술하고 정의하는 공식표준이나 다른기술규격
- 웹 호환성: 이용자의 단말기의 하드웨어 및 소프트웨어 환경이 다른 경우에도 동등한 서비스 제공
- 웹 접근성 : 장애인/비장애인 모두 동등하게 웹사이트에 접근하여 이용 > ALT태그이용
- 반응형 웹 : 디바이스 크기에 맞춰 사이트를 보여줌
- 인포그래픽 : 정보와 그래픽의 합성어, 복잡한 정보를 쉽고 빠르게 전달하기 위해 정보를 시각화한 것
- 브랜드 아이덴티티(BI): 특정브랜드의 가치와 의미를 반영한 심적표상
- 내비게이션 : 하이퍼링크를 따라 웹 공간의 정보를 요청하고 받아오는 웹브라우징
- 아코디언 : 원하는 정보만 선택적으로볼수 있게 접을 수 있는 패널 (더보기,접은글)
- 플레이스홀더 : 값 입력시 참고핤 있도록 입력필드에 제공되는 텍스트 도움말
- 필터링 : 원하지 않는 데이터 차단
- 입력폼 : 다양한 입력필드로 구성, 웹문서의 일부
- 입력필드 : 사용자가 정보를 입력하거나 선택하는데 이용되는 인터페이스 요소
- 썸네일 : 커다란 이미지를 축소(용량도)하여 제공한 이미지
- 레이블 : 다양한 입력필드 식별을 위해 사용되는 명칭
- 대체텍스트 Alternative Text : ALT태그, 콘텐츠를 대신하기 위해 제공되는 텍스트
- 초점 : 웹페이지에서 사용자가 선택한 해당요소에 있을때 


## 개발환경 구축
1. 서버환경구축
  - 웹서버 : 클라이언트에게 정적파일을 제공하는 웹서버 애플리케이션이 설치된 하드웨어(아파치)
  - 웹 애플리케이션 서버(was) : 동적인 웹서비스 제공을 위한 미들웨어가 설치된 하드웨어(제우스,톰캣,웹로직,웹스피어)
  - 데이터베이스 서버(dbms) : 데이터의 저장관리를 위한 데이터베이스 소프트웨어가 설치된 하드웨어(오라클,mysql, ms-sql)
  - 파일서버 : 사용자의 파일을 저장하고 파일을 공유할 목적으로 구성된 하드웨어
  - 로드밸런서 : 여러대의 서버가 조냊할 경우 요청을 적절히 분배해주는 역할
  - CDN : 용량이 큰 콘텐츠 데이터를 빠른 속도로 제공하기 위해 사용자가 가까운 곳에 분산된 데이터 저장 서버 Content delivery network , 투명성 제공
  - 시스템 아키텍처 고려사항 : 확장성, 성능, 응답시간, 처리량, 접근성, 일관성

2. 개발 소프트웨어 환경
  - 시스템 소프트웨어
    - 운영체제 : 윈도우, 리눅스, 유닉스 등
    - JVM : JAVA 관련 프로그램을 가동하기 위한 환경
    - 웹서버: 정적 웹 서비스를 수행 (아파치)
    - WAS : 동적인 웹서비스 수행하는 미들웨어
    - DBMS : 데이터 저장과 관리를 위한 데이터베이스 소프트웨어

  - 개발 소프트웨어
    - 요구사항 관리도구 : 고객의 요구사항을 수집,분석,추적을 쉽게 할 수 있도록 지원
    - 설계/모델링 도구 : 기능을 논리적으로 표현할 수 있는 통합 모델링 언어(UML) 지원
    - 구현도구 : 소프트웨어를 언어를 통해 구현 및 개발을 지원하는 도구(이클립스, 인텔리제이 등)
    - 테스트도구 : 요구사항에 적합하게 구현됐는지 테스트를 지원하는 도구(junit, cppunit)
    - 스트레스 테스트 도구 : 스레드를 설정해서 서버한테 부하를 던짐
    - 형상관리 도구: 산출물 및 소스코드 변경사항을 버전별로 관리하여 목표 시스템의 품질향상을 지원(cvs, svn, git)

3. IDE도구
  - 소프트웨어 개발에 필요한 많은 도구의 기능을 하나로 묶어 활용하는 소프트웨어
  - 적정성 , 효율성, 이식성, 친밀성, 범용성
  - 통합개발도구


4. 협업도구
  - 여러 사용자가 각 작업환경에서 하나의 프로젝트를 동시에 수행할 수 있도록 도와준다. 대부분 saas 소프트웨어형 서비스 클라우드 기반으로 한다.

5. 형상관리도구
- 소프트웨어 생명주기 동안 발생하는 변경사항을 통제하기 위한 관리, 소프트웨어 변경사항을 체계적으로 관리
- 변경관리, 버전관리, 형상관리
- 식통감기(형상식별-**형상통제**-형상감사-형상기록)
- **형상통제** : 소프트웨어 형상 변경요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제


6. 버전관리도구
- 동일한 소스코드에 대한 여러 버전을 관리하는 것
- 공유폴더방식(RCS, SCCS): 소스파일의 수정을 한사람으로 제한
- 클라이언트/서버 방식(CVS -> SVN) : 중앙에 버전관리 시스템이 항상 동작, 
- 분산저장소 방식(git): 로컬 저장소와 원격 저장소, 중앙의 저장소에서 로컬에 복사한 순간 개발자 자신만의 로컬저장소에 생성, 개발 완료 후 파일 수정 이후 로컬 저장소에 커밋한 이후 다시 원격 저장소에 반영하는 방식


7. 빌드 자동화 도구
- 빌드: 소스코드 파일을 컴퓨터에서 실행할 수 있는 소프트웨어로 변환하는 일련의 과정
- 빌드, 테스트, 배포를 자동으로 수행하는 도구
- gradle(groovy기반 오픈소스 , 안드로이드앱개발 환경에서 사용), maven(pom.xml), jenkins(java기반,ci제공, 서블릿 컨테이너), make(유닉스), Ant(xml기반 빌드스크립트로 개발, java)
- 지속적인 통합(ci) : 변경된 소스코드 모아둠
- 지속적인 배포(cd) : 지속적으로 통합한 것을 지속적으로 배포함(사용자들한테 보여줌)
- 빌드-테스트-배포(cd)

- 분산저장소 방식(git): 로컬 저장소와 원격 저장소, 중앙의 저장소에서 로컬에 복사한 순간 개발자 자신만의 로컬저장소에 생성, 개발 완료 후 파일 수정 이후 로컬 저장소에 커밋한 이후 다시 원격 저장소에 반영하는 방식ㅁㅔㅇ
- 분산저장소 방식(git): 로컬 저장소와 원격 저장소, 중앙의 저장소에서 로컬에 복사한 순간 개발자 자신만의 로컬저장소에 생성, 개발 완료 후 파일 수정 이후 로컬 저장소에 커밋한 이후 다시 원격 저장소에 반영하는 방식


## 인터페이스 기능구현
1. 내외부 모듈 연계방식
  - EAI Enterprise Application Integration
  - 기업에서 서로다른 플랫폼 및 애플리케이션들간의 정보전달, 연계, 통합을 가능하게 해주는 솔루션
  - 포허메하
  - 포인투포인투: 중간에 미들웨어를 두지 않고 각 애플리케이션끼리 포인트 투 포인투 형태로 연결
  - 허브앤스포크 : 단일접점 허브시스템을 통해 데이터를 전송하는 중앙 집중적 방식
  - 메세지버스 : 애플리케이션 사이 미들웨어를 두어 처리(esb방식)
  - 하이브리드: 그룹 내에서는 허브앤스포크를 사용하고 외부에서는 메세지버스를 이용하는 방식, 병목현상 최소화
  - ESB: Enterprise Service Bus , 다양한 시스템과 연동하기 위한 멀티 프로토콜 지원
    - 버스를 통해 이기종 애플리케이션을 유연하게 통합하는 핵심 플랫폼
    - EAI와 유연하지만 어플리케이션보단 서비스 중심으로 통합을 지향하는 아키텍처 또는 기술이다.

2. 인터페이스 연계 기술(링커에제소하)
  - Link : 데이터베이스에 제공하는 DB Link 객체 이용
  - DB Connection : 커넥션풀을 생성하고 연계프로그램에서 해당 디비 커넥션풀명을 이용함.
  - JDBC : JDBC를 이용하여 송신시스템 DB와 연결
  - API/OPEN API : 송신 시스템의 애플리케이션 프로그래밍 인터페이스 프로그램
  - **web service** : WSDL(XML 설명서), UDDI, SOAP(실제로 통신할수 있는 프로토콜)
    - 프로토콜을 이용하여 연계
  - 하이퍼링크 Hyper link
  - socket 소켓 : 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신요청시 클라이언트와 연결하고 통신하는 네트워크 기술


3. 인터페이스 전송데이터
  - JSON : 자바스크립트로된 데이터를 표현하기 위한 문자기반의 표준포맷, {}이름,값 쌍
  - XML: 확장된 다목적 마크업 언어, 문서내용에 대한 구조와 의미를 기술
  - HTML, SGML
  - CSV(쉼표로 구분,표형태 저장), YAML(데이터 직렬화 언어,공백+엔터로 구분)

4. 인터페이스 구현
  - AJAX : 자바스크립트를 이용해서 서버와 브라우저가 **비동기**방식으로 데이터를 교환할 수 있는 통신기능, 전체페이지를 새로고침 하지 않고 페이지의 일부만 변경(대선때 득표처럼 비동기)
  - SOAP : 웹서비스에서 기본적인 메세지 전달하는 기반이 됨, HTTP, HTTPS, SMTP를 통해 XML기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜, RPC(외부프로시저콜)패턴 많이 사용, SOA 서비스지향
  - WSDL(XML로 만들어진 설명서), UDDI(이 설명서가 모아져있는 자료실), SOAP
  - REST : HTTP URI를 통해 자원을 명시하고, POST, GET, PUT, DELETE를 통해 자원에 대한 CURD 오퍼레이션 적용, 자원기반의 구조(ROA)
    - 자원(URI), 행위(메서드-GET,PUT,POST,DELETE),표현(representation)
    - 상태정보유지x, 캐싱기능 적용가능

5. 인터페이스 보안
  - 애플리케이션 보안(시큐어 코딩)
  - 데이터베이스 보안(민감 데이터를 암호화, 익명화 등 데이터 자체 보안)
  - 네트워크 영역(IP Sec, Https(SSL), S-HTTP) : 스니핑, 탈취, 변조 위협 방지 및 네트워크 트래픽에 대한 암호화 설정

5. 인터페이스 구현 검증
  - 엑스피엔셀웨
  - xunit: 다양한 언어 지원하는 단위테스트 프레임워크
  - STAF: 서비스호출 및 컴포넌트 재사용
  - FitNesse : 웹기반 테스트 프레임워크
  - NTAF:스태프+피트니스 장점 통합(네이버)
  - Selenium : 웹어플리케이션 테스트 프레임워크
  - watir: 루비 기반 어플리케이션 테스트 프레임워크

6. 인터페이스 구현 감시도구
  - 스카우터, 제니퍼
  - apm을 사용하여 동작상태 감시
  - 데이터베이스, 웹 애플리케이션의 다양한 정보를 조회하고 분석하여 시각화함

## 객체지향 설계(디자인 패턴은 시험대비용으로 정리만 해두기)
1. 객체지향(OOP) : 현실세계의 모든 대상을 객체로 나누고 객체의 행동과 고유한 값을 정의하여 설계
2. 객체지향 구성요소
  - 클래스class : 데이터를 추상화하는 단위
  - 객체Object : 클래스의 인스턴스, 메모리에 실제로 올라가는 인스턴스
  - 메서드 method: 객체가 가지고 있는 속성으 ㄹ변경할 수 있는 하나의 연산
  - message 메세지 : 객체의 메서드를 호출함으로서 객체간의 상호작용을 할 수 있도록 함
  - 상속, 캡슐화(데이터와 메서드 하나로 묶은 것)/정보은닉, 추상화, 다형성

3. 객체지향 설계원칙(SOLID)
  - SRP 단일책임원칙 : 한 클래스는 하나의 책임만을 가진다.
  - OCP 개방폐쇄원칙: 확장에는 열려있고 수정에는 닫혀야 한다.
  - LSP 리스코프치환원칙 : 자식클래스는 언제나 자신의 부모를 대체할 수 있어야 한다.
  - ISP 인터페이스분리원칙 : 사용하지 않는 인터페이스는 구현하지 말아야 한다.
  - DIP 의존성 역전원칙 : 자주 변하는 것에 의존 맺지 말아야 한다.

4. 디자인패턴 : 이미 만들어져서 잘 되는 것을 활용하여 재사용함으로써 프로그램 최적화에 도움을 준다. 객체지향 프로그래밍 설계시 자주 발생하는 문제들에 대해 재사용할 수 있더록 만들어놓은 패턴들의 모음.
  - 디자인패턴 구조 : 패문솔사결샘
  - 목적으로 분류시 : 생성, 구조, 행위

## 애플리케이션 테스트케이스
1. 소프트웨어 테스트 : 숨어있는 결함을 찾기 위한 행위와 절차(오류 발견관점, 오류예방관점, 품질향상관점)
2. 결함집중 : 파레토(20%의 핵심모듈에서 80% 오류가 발생한다.)
3. 살충제 패러독스: 동일한 테스트 케이스 반복은 결함을 발견할 수 없다.(주기적 리뷰,개선 해야함)
4. 오류-부재의 궤변: 사용자의 요구사항을 만족하지 못하면 품질이 높다고 할 수 없다.
5. 테스트 프로세스: 테스트계획-테스트 분석/디자인 - 테스트케이스/시나리오 작성-테스트수행-테스트 결과평가 및 리포팅
6. 테스트 산출물: 테스트계획서, 테스트케이스, 테스트 시나리오, 테스트 결과서
7. 테스트 오라클(참샘휴일) : 테스트의 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 참값을 입력하여 비교하는 기법,활동
  - 참: 모든 테스트 케이스를 다 수행한다. (항공기,임베디드 등 크리티컬한 업무)
  - 샘플링: 일반적 업무에서 사용, 특정한것/중요한 것 추려서 결과 제공
  - 휴리스틱: 샘플링을 수행하고 나머지는 추정하는 오라클
  - 일관성 검사: 변경이 있을때 수행전과 수행후 결과값이 동일한지 확인하는 오라클 

8. 테스트 레벨(단통시인)
- 단위 테스트: 정적테스트, 동적테스트
- 통합테스트: 각각의 모듈을 통합하면서 상향,하향,빅뱅,백본 테스트 진행 
- 시스템 테스트: 기능/비기능
- 인수테스트: 알파/베타

9. 프로그램 실행여부에 따른 테스트 기법
- 정적테스트: 소프트웨어 실행없이 소스코드 논리적으로 검증, 경로분석, 제어흐름분석, 데이터 흐름분석 수행
- 동적테스트: 소프트웨어를 실행하여 실제 발생하는 오류를 발견, 다양한 운영환경에서 소프트웨어 분석

10. 테스트 기법
- 화이트박스 테스트: 소스코드 내부구조와 동작 검사
- 문장검증 : 전부 검증, 선택(분기)검증 : 선택하는 부분만 검증
- 경로검증: 소행가능한 모든경로 검사
- 조건검증: 조건식을 검사
- 맥케이브 : 브랜치 - 노드 + 2 대표적인 화이트박스 테스트 기법
- 블랙박스 테스트: 요구사항명세를 보면서 구현된 기능을 테스트, 사용자 관점의 테스트 방법
- 동등분할기법 : Equivalence partitioning tesitng 80~90사이일때 85를 넣는 거
- 경계값분석 bonudary value analysis 
- 원인-효과그래프 cause effect : 입력데이터간의 관계와 출력에 영향 graphing testin
- 오류예측 : 경험많은 테스터가 테스트 error guessing
- 비교검사 comparison testing 여러버전의 테스트자료로 동일한 결과가 출력되는지 테스트

11. 테스트에 대한 시각에 따른 테스트 기법
- 검증(verification) : 소프트웨어 개발 과정 테스트, 개발자가 하는 것
- 확인(validation) : 내가 원하는 기능이 정상적으로 돌아가는지 테스트, 사용자 관점

12. 테스트 목적에 따른 테스트 기법
- 회복(recovery) : 일부러 실패를 유도하고 복귀하는지 테스트
- 안전(security) : 소스코드 내 보안적인 결함 미리 점검
- 강도(stress) : 시스템에 부하를 주고 정상적으로 작동하는지 검증
- 성능( performance):  시스템의 응답시간, 처리량, 반응속도 등 성능 테스트
- 구조(structure): 시스템의 내부논리경로,소스코드 복잡도 평가
- 회귀(regression) : 수정했을때 새 결함발견 여부 평가
- 병행(parallel)
- A/B 테스트, 스모크 테스트(테스트 환경 테스트)

13. 테스트 종류에 따른 기법
 - 명세기반 테스트 : 명세서를 보면서 테스트
 - 구조기반 테스트 : 테스트케이스 작성하고 확인하는 테스트
 - >>> 이 두 개는 매우 오래걸리므로 거의 경험기반을 진행함.
 - 경험기반 테스트 : 경험이 많은 테스터의 직관과 기술능력 기반으로 수행

14. 테스트 커버리지
- 테스트를 얼마나 수행했는지 측정하는 기준
- 기능 기반 커버리지: 기능을 모수로 테스트가 수행된 기능 수 측정
- 라인 커버리지: 소스코드 라인수를 모수로 설정,
- 코드 커버리지 : 소스코드 구조를 봄
  - 구문 : 모든 구문에 대해 한번이상 수행(statement)
  - **결정** : 결정포인트 내 모든 분기문에 수행하는 테스트 커버리지(결정포인트가 T랑 F 둘다 나와야 함)
  - **조건** : 결정포인트(이프문 안에 조건2개일때) 내 모든 개별조건식(2개중 1개)에 대해 수행한다. --> 1번조건에서 t/f 나오고 2번조건에서 t/f 나와야 함(결정포인트는 의미없음)
  - 조건/결정 : 결정포인트 T/F , 개별조건식도 T/F를 가져야 함.
  - 변경 조건/결정 : 모든 결정포인트내의 개별조건식은 **적어도 한번** T/F를 가져야 함. (가장안전)
  - 다중 조건 커버리지: 결정포인트내 모든 개별조건식의 가능한 조합을 100% 보장(TT,TF,FT,FF 등)


## 애플리케이션 통합 테스트
1. 결함관리 도구: 결함 재발 방지를 위해 유사 결함 발견시 추적하고 관리할 수 있게 해주는 도구
2. 결함관리 프로세스: 에러발견-에러등록-에러분석-결함확정-결함할당-결함조치-결함조치 검토및 승인
3. 결함관리 측정지표: 결함분포, 결함추세, 결함에이징,
4. 테스트 자동화 도구: 테스트 작업을 스크립트로 형태로 구현하여 테스트 반복 수행
  - 엑셀로 만들어놓으면 지가 알아서 테스트를 수행해줌
  - 사용 방법이 엄청 어려워서 학습및 교육이 필요함+비용
  - 정적분석도구: 애플리케이션을 실행하지 않고 분석하는 도구(코딩표준,코딩스타일,코드복잡도 등 남은 결함 발견 위해 사용함), pmd, sonarQube, cppcheck, checkstyle 등
  - 테스트 실행 도구: 테스트를 위해 작성된 스크립트를 실행(데이터 주도 접근방식, 키워드 주도 접근 방식)
  - 성능테스트 도구: stress테스트 할때 사용함, 많은 수의 가상 사용자를 생성하여 부하를 테스트 애플리케이션의 처리량,응답시간, 경과시간, 자원사용률을 확인하여 성능목표를 달성했는지 확인한다.
  - 테스트 통제도구
  - 테스트 장치: 컴포넌트 및 모듈을 테스트하는 일부분 
    - 테스트 드라이버: 상향식테스트에서 사용, 필요 데이터를 인자를 통해 넘겨주고 테스트 완료후 결과값을 받음 
    - 테스트 스텁: 하향식 테스트, 제어모듈이 호출하는 타모듈의 기능을 단순히 수행하는 도구
    - 테스트 슈트: 테스트 케이스의 집합
    - 테스트 케이스: 입력값, 실행조건, 기대결과 등의 집합
    - 테스트 시나리오: 테스트 케이스를 엮은 것
    - 테스트 스크립트: 자동화된 테스트 실행절차에 대한 명세
    - 목 오브젝트: 상황에 예정된 행위를 수행하는 객체, 임시모듈

5. 통합테스트: 점증적 방식(상향식-드라이버,하향식-스텁, 백), 비점증적 방식(빅뱅)
- 하향식 통합 테스트: 아직 개발되지 않은 하위모듈은 더미모듈인 스텁 이용
- 상향식 통합 테스트: 하위모듈을 클러스터로 결합하면서 위쪽 방향으로 진행, 반환값을 전달하는 드라이버 사용
- 빅뱅 테스트: 모든 구성요소들을 한꺼번에 통합하여 테스트, 소규모 시스템 테스트
- 백본 테스트: 샌드위치 테스트, 상향식과 하향식의 장점을 이용해서 같이 진행한다. 대규모 프로젝트, 비용 많이 소모


## 애플리케이션 성능 개선
1. 데이터베이스 관련 성능저하: DB Lock, DB Fetch(불필요한 패치), 연결 누수(Connection Leack)
2. 내부로직으로 인한 성능저하: 파일관련 오류, 코드오류
3. 외부호출로 인한 성능저하: 장시간 수행, 타임아웃 -> 성능저하
**4**. 애플리케이션 성능분석지표(처리량, 응답시간, 반환(경과)시간, 자원사용률)
5. 성능분석도구: JMeter, LoadUI, OPENSTA
6. 모니터링 도구(APM도구) : Scouter, NMon, Zabbix, jeniffer(서버로 유입되는 자원활용률 모니터링)
7. 정형기술 검토회의(FTR) : 소프트웨어 개발산출물을 대상으로 오류를 발견하기 위한 공식활동, formal technical review
8. 소스코드 품질분석(동워인)
  - 동료검토(peer review) : 2~3명이 진행, 작성자가 코드를 설명하고 이해관계자들이 설명을 들으며 결함을 발견하는 형태
  - 워크스루(walkthrough) : 검토자료를 회의 전에 배포해서 사전검토 후 짧은시간동안 회의진행, 팀회의
  - 인스펙션(inspection) : 작업자 외 다른 전문가가 검사하는 공식적인 리뷰기법, 인스펙션 과정: 계획-사전교육-준비-인스펙션회의-수정-후속조치
  - 리팩토링: 외부동작을 바꾸지 않으면서 내부구조를 개선하는 방법. 이미 작성한 소스코드에서 **기능의 변경**없이 가독성과 유지보수성을 높이기 위해 내부 구조를 변경하는 것. 동 워 인 > 을 진행 후 나오는 문제점을 개선하기 위해 리팩토링 수행
 
9. 소스코드 품질분석도구: 코딩하면서 발생하는 문제 해결위해 사용하는 도구
  - 정적분석도구: 프로그램을 실행하지 않고 소프트웨어 분석, 각종 결함을 소스코드 분석을 통해 확인, pmd, checkstyle,ccm,cobertura,cppcheck
  - 동적분석도구: 프로그램을 실행하여 코드에 존재하는 메모리 누수나 스레드 결함 발견, valgrind, avalnche
  
10. 애플리케이션 성능계산하기: 코드 최적화(알고리즘 개선,병목현상 제거, 리팩토링을 통해 코드스멜 제거)
11. 코드스멜: 코드에서 더 심각한 문제를 일으킬 가능성이 있는 프로그램 소스코드(중복된 코드, 긴 메서드, 큰 클래스, 클래스 동시 수정)
  - 스파게티코드: 소스코드가 복잡하게 얽힌 것. goto문을 지나치게 많이 사용하거나 구조적으로 만들어지지 않은 경우
  - 외계인 코드: 개발자가 없거나 개발문서가 너무 오래돼서 유지보수가 어려운 코드
12. 클린코드: 의존성 최소, 사람이 이해할 수 있는 가독성, 목적성이 뛰어난 명확한 코드 >> 클린코드 작성원칙: 가단의중추


## 소프트웨어 유지보수
1. 소프트웨어 유지보수: 개발완료 시점부터 폐기될때까지 지속적으로 수행하는 작업, 소프트웨어 생명주기 동안 가장 많은 비용이 소모되는 단계
2. 유지보수의 구분
  - 수정보수 : 소프트웨어 구축시 테스트단계에서 미처 발견하지 못한 잠재적인 오류를 찾아 수정
  - 적응보수 : 환경변화에 맞추기 위해 수행하는 유지보수
  - 향상보수 : 기존의 기능과 다른 새로운 기능 추가하거나 개선하는 유지보수
  - 예방보수 : 장래의 유지보수 또는 신뢰성을 보장하기 위해 선제적으로 하는 유지보수, 소프트웨어 재공학과 관련된 유지보수
